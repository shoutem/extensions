diff --git a/node_modules/react-native-permissions/android/src/main/java/com/zoontek/rnpermissions/RNPermissionsModuleImpl.java b/node_modules/react-native-permissions/android/src/main/java/com/zoontek/rnpermissions/RNPermissionsModuleImpl.java
index 97bc712..1088eda 100644
--- a/node_modules/react-native-permissions/android/src/main/java/com/zoontek/rnpermissions/RNPermissionsModuleImpl.java
+++ b/node_modules/react-native-permissions/android/src/main/java/com/zoontek/rnpermissions/RNPermissionsModuleImpl.java
@@ -2,6 +2,7 @@ package com.zoontek.rnpermissions;
 
 import android.Manifest;
 import android.app.Activity;
+import android.app.AlarmManager;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -10,6 +11,7 @@ import android.os.Build;
 import android.os.Process;
 import android.provider.Settings;
 import android.util.SparseArray;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 import androidx.core.app.NotificationManagerCompat;
@@ -31,336 +33,369 @@ import java.util.Map;
 
 public class RNPermissionsModuleImpl {
 
-  private static final String ERROR_INVALID_ACTIVITY = "E_INVALID_ACTIVITY";
-  public static final String NAME = "RNPermissions";
-
-  private static int mRequestCode = 0;
-  private static final String GRANTED = "granted";
-  private static final String DENIED = "denied";
-  private static final String UNAVAILABLE = "unavailable";
-  private static final String BLOCKED = "blocked";
-
-  public static Map<String, Object> getConstants() {
-    HashMap<String, Object> constants = new HashMap<>();
-    constants.put("available", Arguments.createArray());
-    return constants;
-  }
-
-  private static boolean isPermissionUnavailable(@NonNull final String permission) {
-    String fieldName = permission
-      .replace("android.permission.", "")
-      .replace("com.android.voicemail.permission.", "");
-
-    try {
-      Manifest.permission.class.getField(fieldName);
-      return false;
-    } catch (NoSuchFieldException ignored) {
-      return true;
-    }
-  }
-
-  // Only used on Android < 13 (the POST_NOTIFICATIONS runtime permission isn't available)
-  private static WritableMap getLegacyNotificationsResponse(
-    final ReactApplicationContext reactContext,
-    final String disabledStatus
-  ) {
-    final boolean enabled = NotificationManagerCompat.from(reactContext).areNotificationsEnabled();
-    final WritableMap output = Arguments.createMap();
-    final WritableMap settings = Arguments.createMap();
-
-    output.putString("status", enabled ? GRANTED : disabledStatus);
-    output.putMap("settings", settings);
-
-    return output;
-  }
-
-  public static void openSettings(
-    final ReactApplicationContext reactContext,
-    final Promise promise
-  ) {
-    try {
-      final Intent intent = new Intent();
-      final String packageName = reactContext.getPackageName();
-
-      intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
-      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-      intent.setData(Uri.fromParts("package", packageName, null));
-
-      reactContext.startActivity(intent);
-      promise.resolve(true);
-    } catch (Exception e) {
-      promise.reject(ERROR_INVALID_ACTIVITY, e);
-    }
-  }
-
-  public static void check(
-    final ReactApplicationContext reactContext,
-    final String permission,
-    final Promise promise
-  ) {
-    if (permission == null || isPermissionUnavailable(permission)) {
-      promise.resolve(UNAVAILABLE);
-      return;
-    }
+    private static final String ERROR_INVALID_ACTIVITY = "E_INVALID_ACTIVITY";
+    public static final String NAME = "RNPermissions";
 
-    Context context = reactContext.getBaseContext();
+    private static int mRequestCode = 0;
+    private static final String GRANTED = "granted";
+    private static final String DENIED = "denied";
+    private static final String UNAVAILABLE = "unavailable";
+    private static final String BLOCKED = "blocked";
 
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid())
-        == PackageManager.PERMISSION_GRANTED
-        ? GRANTED
-        : BLOCKED);
-      return;
+    public static Map<String, Object> getConstants() {
+        HashMap<String, Object> constants = new HashMap<>();
+        constants.put("available", Arguments.createArray());
+        return constants;
     }
 
-    if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
-      promise.resolve(GRANTED);
-    } else {
-      promise.resolve(DENIED);
-    }
-  }
-
-  public static void checkNotifications(
-    final ReactApplicationContext reactContext,
-    final Promise promise
-  ) {
-    promise.resolve(getLegacyNotificationsResponse(reactContext, DENIED));
-  }
-
-  public static void checkMultiple(
-    final ReactApplicationContext reactContext,
-    final ReadableArray permissions,
-    final Promise promise
-  ) {
-    final WritableMap output = new WritableNativeMap();
-    Context context = reactContext.getBaseContext();
-
-    for (int i = 0; i < permissions.size(); i++) {
-      String permission = permissions.getString(i);
-
-      if (isPermissionUnavailable(permission)) {
-        output.putString(permission, UNAVAILABLE);
-      } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-        output.putString(
-          permission,
-          context.checkPermission(permission, Process.myPid(), Process.myUid())
-            == PackageManager.PERMISSION_GRANTED
-            ? GRANTED
-            : BLOCKED);
-      } else if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
-        output.putString(permission, GRANTED);
-      } else {
-        output.putString(permission, DENIED);
-      }
+    private static boolean isPermissionUnavailable(@NonNull final String permission) {
+        String fieldName = permission
+            .replace("android.permission.", "")
+            .replace("com.android.voicemail.permission.", "");
+
+        try {
+            Manifest.permission.class.getField(fieldName);
+            return false;
+        } catch (NoSuchFieldException ignored) {
+            return true;
+        }
     }
 
-    promise.resolve(output);
-  }
-
-  public static void request(
-    final ReactApplicationContext reactContext,
-    final PermissionListener listener,
-    final SparseArray<Callback> callbacks,
-    final String permission,
-    final Promise promise
-  ) {
-    if (permission == null || isPermissionUnavailable(permission)) {
-      promise.resolve(UNAVAILABLE);
-      return;
+    public static boolean canScheduleExactAlarms(
+        final ReactApplicationContext reactContext
+    ) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+            AlarmManager alarmManager = (AlarmManager) reactContext.getSystemService(Context.ALARM_SERVICE);
+
+            return alarmManager.canScheduleExactAlarms();
+        }
+        return true;
     }
 
-    Context context = reactContext.getBaseContext();
+    // Only used on Android < 13 (the POST_NOTIFICATIONS runtime permission isn't available)
+    private static WritableMap getLegacyNotificationsResponse(
+        final ReactApplicationContext reactContext,
+        final String disabledStatus
+    ) {
+        final boolean enabled = NotificationManagerCompat.from(reactContext).areNotificationsEnabled();
+        final WritableMap output = Arguments.createMap();
+        final WritableMap settings = Arguments.createMap();
+
+        output.putString("status", enabled ? GRANTED : disabledStatus);
+        output.putMap("settings", settings);
 
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-      promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid())
-        == PackageManager.PERMISSION_GRANTED
-        ? GRANTED
-        : BLOCKED);
-      return;
+        return output;
     }
 
-    if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
-      promise.resolve(GRANTED);
-      return;
+    public static void openSettings(
+        final ReactApplicationContext reactContext,
+        final Promise promise
+    ) {
+        try {
+            final Intent intent = new Intent();
+            final String packageName = reactContext.getPackageName();
+
+            intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            intent.setData(Uri.fromParts("package", packageName, null));
+
+            reactContext.startActivity(intent);
+            promise.resolve(true);
+        } catch (Exception e) {
+            promise.reject(ERROR_INVALID_ACTIVITY, e);
+        }
     }
 
-    try {
-      PermissionAwareActivity activity = getPermissionAwareActivity(reactContext);
+    public static void openAlarmPermissionSettings(
+        final ReactApplicationContext reactContext,
+        final Promise promise
+    ) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
+            return;
+        }
+
+        try {
+            Intent intent = new Intent();
+            final String packageName = reactContext.getPackageName();
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            intent.setAction(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);
+            intent.setData(Uri.fromParts("package", packageName, null));
+
+            reactContext.startActivity(intent);
+            promise.resolve(true);
+        } catch (Exception e) {
+            promise.reject(ERROR_INVALID_ACTIVITY, e);
+        }
+    }
 
-      callbacks.put(
-        mRequestCode,
-        new Callback() {
-          @Override
-          public void invoke(Object... args) {
-            int[] results = (int[]) args[0];
+    public static void check(
+        final ReactApplicationContext reactContext,
+        final String permission,
+        final Promise promise
+    ) {
+        if (permission == null || isPermissionUnavailable(permission)) {
+            promise.resolve(UNAVAILABLE);
+            return;
+        }
+
+        Context context = reactContext.getBaseContext();
+
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+            promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid())
+                == PackageManager.PERMISSION_GRANTED
+                ? GRANTED
+                : BLOCKED);
+            return;
+        }
+
+        if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
+            promise.resolve(GRANTED);
+        } else {
+            promise.resolve(DENIED);
+        }
+    }
 
-            if (results.length > 0 && results[0] == PackageManager.PERMISSION_GRANTED) {
-              promise.resolve(GRANTED);
-            } else {
-              PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
+    public static void checkNotifications(
+        final ReactApplicationContext reactContext,
+        final Promise promise
+    ) {
+        promise.resolve(getLegacyNotificationsResponse(reactContext, DENIED));
+    }
 
-              if (activity.shouldShowRequestPermissionRationale(permission)) {
-                promise.resolve(DENIED);
-              } else {
-                promise.resolve(BLOCKED);
-              }
+    public static void checkMultiple(
+        final ReactApplicationContext reactContext,
+        final ReadableArray permissions,
+        final Promise promise
+    ) {
+        final WritableMap output = new WritableNativeMap();
+        Context context = reactContext.getBaseContext();
+
+        for (int i = 0; i < permissions.size(); i++) {
+            String permission = permissions.getString(i);
+
+            if (isPermissionUnavailable(permission)) {
+                output.putString(permission, UNAVAILABLE);
+            } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+                output.putString(
+                    permission,
+                    context.checkPermission(permission, Process.myPid(), Process.myUid())
+                        == PackageManager.PERMISSION_GRANTED
+                        ? GRANTED
+                        : BLOCKED);
+            } else if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
+                output.putString(permission, GRANTED);
+            } else {
+                output.putString(permission, DENIED);
             }
-          }
-        });
+        }
 
-      activity.requestPermissions(new String[] {permission}, mRequestCode, listener);
-      mRequestCode++;
-    } catch (IllegalStateException e) {
-      promise.reject(ERROR_INVALID_ACTIVITY, e);
-    }
-  }
-
-  public static void requestNotifications(
-    final ReactApplicationContext reactContext,
-    final Promise promise
-  ) {
-    promise.resolve(getLegacyNotificationsResponse(reactContext, BLOCKED));
-  }
-
-  public static void requestMultiple(
-    final ReactApplicationContext reactContext,
-    final PermissionListener listener,
-    final SparseArray<Callback> callbacks,
-    final ReadableArray permissions,
-    final Promise promise
-  ) {
-    final WritableMap output = new WritableNativeMap();
-    final ArrayList<String> permissionsToCheck = new ArrayList<String>();
-    int checkedPermissionsCount = 0;
-    Context context = reactContext.getBaseContext();
-
-    for (int i = 0; i < permissions.size(); i++) {
-      String permission = permissions.getString(i);
-
-      if (isPermissionUnavailable(permission)) {
-        output.putString(permission, UNAVAILABLE);
-        checkedPermissionsCount++;
-      } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-        output.putString(
-          permission,
-          context.checkPermission(permission, Process.myPid(), Process.myUid())
-            == PackageManager.PERMISSION_GRANTED
-            ? GRANTED
-            : BLOCKED);
-
-        checkedPermissionsCount++;
-      } else if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
-        output.putString(permission, GRANTED);
-        checkedPermissionsCount++;
-      } else {
-        permissionsToCheck.add(permission);
-      }
+        promise.resolve(output);
     }
 
-    if (permissions.size() == checkedPermissionsCount) {
-      promise.resolve(output);
-      return;
+    public static void request(
+        final ReactApplicationContext reactContext,
+        final PermissionListener listener,
+        final SparseArray<Callback> callbacks,
+        final String permission,
+        final Promise promise
+    ) {
+        if (permission == null || isPermissionUnavailable(permission)) {
+            promise.resolve(UNAVAILABLE);
+            return;
+        }
+
+        Context context = reactContext.getBaseContext();
+
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+            promise.resolve(context.checkPermission(permission, Process.myPid(), Process.myUid())
+                == PackageManager.PERMISSION_GRANTED
+                ? GRANTED
+                : BLOCKED);
+            return;
+        }
+
+        if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
+            promise.resolve(GRANTED);
+            return;
+        }
+
+        try {
+            PermissionAwareActivity activity = getPermissionAwareActivity(reactContext);
+
+            callbacks.put(
+                mRequestCode,
+                new Callback() {
+                    @Override
+                    public void invoke(Object... args) {
+                        int[] results = (int[]) args[0];
+
+                        if (results.length > 0 && results[0] == PackageManager.PERMISSION_GRANTED) {
+                            promise.resolve(GRANTED);
+                        } else {
+                            PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
+
+                            if (activity.shouldShowRequestPermissionRationale(permission)) {
+                                promise.resolve(DENIED);
+                            } else {
+                                promise.resolve(BLOCKED);
+                            }
+                        }
+                    }
+                });
+
+            activity.requestPermissions(new String[]{permission}, mRequestCode, listener);
+            mRequestCode++;
+        } catch (IllegalStateException e) {
+            promise.reject(ERROR_INVALID_ACTIVITY, e);
+        }
     }
 
-    try {
-      PermissionAwareActivity activity = getPermissionAwareActivity(reactContext);
-
-      callbacks.put(
-        mRequestCode,
-        new Callback() {
-          @Override
-          public void invoke(Object... args) {
-            int[] results = (int[]) args[0];
-            PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
-
-            for (int j = 0; j < permissionsToCheck.size(); j++) {
-              String permission = permissionsToCheck.get(j);
+    public static void requestNotifications(
+        final ReactApplicationContext reactContext,
+        final Promise promise
+    ) {
+        promise.resolve(getLegacyNotificationsResponse(reactContext, BLOCKED));
+    }
 
-              if (results.length > 0 && results[j] == PackageManager.PERMISSION_GRANTED) {
+    public static void requestMultiple(
+        final ReactApplicationContext reactContext,
+        final PermissionListener listener,
+        final SparseArray<Callback> callbacks,
+        final ReadableArray permissions,
+        final Promise promise
+    ) {
+        final WritableMap output = new WritableNativeMap();
+        final ArrayList<String> permissionsToCheck = new ArrayList<String>();
+        int checkedPermissionsCount = 0;
+        Context context = reactContext.getBaseContext();
+
+        for (int i = 0; i < permissions.size(); i++) {
+            String permission = permissions.getString(i);
+
+            if (isPermissionUnavailable(permission)) {
+                output.putString(permission, UNAVAILABLE);
+                checkedPermissionsCount++;
+            } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+                output.putString(
+                    permission,
+                    context.checkPermission(permission, Process.myPid(), Process.myUid())
+                        == PackageManager.PERMISSION_GRANTED
+                        ? GRANTED
+                        : BLOCKED);
+
+                checkedPermissionsCount++;
+            } else if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {
                 output.putString(permission, GRANTED);
-              } else {
-                if (activity.shouldShowRequestPermissionRationale(permission)) {
-                  output.putString(permission, DENIED);
-                } else {
-                  output.putString(permission, BLOCKED);
-                }
-              }
+                checkedPermissionsCount++;
+            } else {
+                permissionsToCheck.add(permission);
             }
+        }
 
+        if (permissions.size() == checkedPermissionsCount) {
             promise.resolve(output);
-          }
-        });
+            return;
+        }
+
+        try {
+            PermissionAwareActivity activity = getPermissionAwareActivity(reactContext);
+
+            callbacks.put(
+                mRequestCode,
+                new Callback() {
+                    @Override
+                    public void invoke(Object... args) {
+                        int[] results = (int[]) args[0];
+                        PermissionAwareActivity activity = (PermissionAwareActivity) args[1];
+
+                        for (int j = 0; j < permissionsToCheck.size(); j++) {
+                            String permission = permissionsToCheck.get(j);
+
+                            if (results.length > 0 && results[j] == PackageManager.PERMISSION_GRANTED) {
+                                output.putString(permission, GRANTED);
+                            } else {
+                                if (activity.shouldShowRequestPermissionRationale(permission)) {
+                                    output.putString(permission, DENIED);
+                                } else {
+                                    output.putString(permission, BLOCKED);
+                                }
+                            }
+                        }
+
+                        promise.resolve(output);
+                    }
+                });
+
+            activity.requestPermissions(permissionsToCheck.toArray(new String[0]), mRequestCode, listener);
+            mRequestCode++;
+        } catch (IllegalStateException e) {
+            promise.reject(ERROR_INVALID_ACTIVITY, e);
+        }
+    }
 
-      activity.requestPermissions(permissionsToCheck.toArray(new String[0]), mRequestCode, listener);
-      mRequestCode++;
-    } catch (IllegalStateException e) {
-      promise.reject(ERROR_INVALID_ACTIVITY, e);
+    public static void shouldShowRequestRationale(
+        final ReactApplicationContext reactContext,
+        final String permission,
+        final Promise promise
+    ) {
+        if (permission == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+            promise.resolve(false);
+            return;
+        }
+
+        try {
+            promise.resolve(getPermissionAwareActivity(reactContext)
+                .shouldShowRequestPermissionRationale(permission));
+        } catch (IllegalStateException e) {
+            promise.reject(ERROR_INVALID_ACTIVITY, e);
+        }
     }
-  }
-
-  public static void shouldShowRequestRationale(
-    final ReactApplicationContext reactContext,
-    final String permission,
-    final Promise promise
-  ) {
-    if (permission == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-      promise.resolve(false);
-      return;
+
+    private static PermissionAwareActivity getPermissionAwareActivity(
+        final ReactApplicationContext reactContext
+    ) {
+        Activity activity = reactContext.getCurrentActivity();
+
+        if (activity == null) {
+            throw new IllegalStateException(
+                "Tried to use permissions API while not attached to an " + "Activity.");
+        } else if (!(activity instanceof PermissionAwareActivity)) {
+            throw new IllegalStateException(
+                "Tried to use permissions API but the host Activity doesn't"
+                    + " implement PermissionAwareActivity.");
+        }
+
+        return (PermissionAwareActivity) activity;
     }
 
-    try {
-      promise.resolve(getPermissionAwareActivity(reactContext)
-        .shouldShowRequestPermissionRationale(permission));
-    } catch (IllegalStateException e) {
-      promise.reject(ERROR_INVALID_ACTIVITY, e);
+    public static void openPhotoPicker(final Promise promise) {
+        promise.reject("Permissions:openPhotoPicker", "openPhotoPicker is not supported on Android");
     }
-  }
-
-  private static PermissionAwareActivity getPermissionAwareActivity(
-    final ReactApplicationContext reactContext
-  ) {
-    Activity activity = reactContext.getCurrentActivity();
-
-    if (activity == null) {
-      throw new IllegalStateException(
-        "Tried to use permissions API while not attached to an " + "Activity.");
-    } else if (!(activity instanceof PermissionAwareActivity)) {
-      throw new IllegalStateException(
-        "Tried to use permissions API but the host Activity doesn't"
-          + " implement PermissionAwareActivity.");
+
+    public static void checkLocationAccuracy(final Promise promise) {
+        promise.reject("Permissions:checkLocationAccuracy", "checkLocationAccuracy is not supported on Android");
+    }
+
+    public static void requestLocationAccuracy(final Promise promise) {
+        promise.reject("Permissions:requestLocationAccuracy", "requestLocationAccuracy is not supported on Android");
     }
 
-    return (PermissionAwareActivity) activity;
-  }
-
-  public static void openPhotoPicker(final Promise promise) {
-    promise.reject("Permissions:openPhotoPicker", "openPhotoPicker is not supported on Android");
-  }
-
-  public static void checkLocationAccuracy(final Promise promise) {
-    promise.reject("Permissions:checkLocationAccuracy", "checkLocationAccuracy is not supported on Android");
-  }
-
-  public static void requestLocationAccuracy(final Promise promise) {
-    promise.reject("Permissions:requestLocationAccuracy", "requestLocationAccuracy is not supported on Android");
-  }
-
-  public static boolean onRequestPermissionsResult(
-    final ReactApplicationContext reactContext,
-    final SparseArray<Callback> callbacks,
-    int requestCode,
-    int[] grantResults
-  ) {
-    try {
-      callbacks.get(requestCode).invoke(grantResults, getPermissionAwareActivity(reactContext));
-      callbacks.remove(requestCode);
-      return callbacks.size() == 0;
-    } catch (Exception e) {
-      FLog.e(
-        "PermissionsModule",
-        e,
-        "Unexpected invocation of `onRequestPermissionsResult`");
-      return false;
+    public static boolean onRequestPermissionsResult(
+        final ReactApplicationContext reactContext,
+        final SparseArray<Callback> callbacks,
+        int requestCode,
+        int[] grantResults
+    ) {
+        try {
+            callbacks.get(requestCode).invoke(grantResults, getPermissionAwareActivity(reactContext));
+            callbacks.remove(requestCode);
+            return callbacks.size() == 0;
+        } catch (Exception e) {
+            FLog.e(
+                "PermissionsModule",
+                e,
+                "Unexpected invocation of `onRequestPermissionsResult`");
+            return false;
+        }
     }
-  }
 }
diff --git a/node_modules/react-native-permissions/android/src/newarch/com/zoontek/rnpermissions/RNPermissionsModule.java b/node_modules/react-native-permissions/android/src/newarch/com/zoontek/rnpermissions/RNPermissionsModule.java
index bdfbe48..14e30ed 100644
--- a/node_modules/react-native-permissions/android/src/newarch/com/zoontek/rnpermissions/RNPermissionsModule.java
+++ b/node_modules/react-native-permissions/android/src/newarch/com/zoontek/rnpermissions/RNPermissionsModule.java
@@ -2,95 +2,158 @@ package com.zoontek.rnpermissions;
 
 import android.util.SparseArray;
 
+import android.app.AlarmManager;
+import android.app.Activity;
+import android.provider.Settings;
+import android.content.Intent;
+import android.content.Context;
+
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.facebook.react.bridge.Callback;
 import com.facebook.react.bridge.Promise;
 import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
 import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ActivityEventListener;
 import com.facebook.react.module.annotations.ReactModule;
 import com.facebook.react.modules.core.PermissionListener;
 
 import java.util.Map;
 
 @ReactModule(name = RNPermissionsModuleImpl.NAME)
-public class RNPermissionsModule extends NativeRNPermissionsSpec implements PermissionListener {
-
-  private final SparseArray<Callback> mCallbacks;
-
-  public RNPermissionsModule(ReactApplicationContext reactContext) {
-    super(reactContext);
-    mCallbacks = new SparseArray<Callback>();
-  }
-
-  @Override
-  @NonNull
-  public String getName() {
-    return RNPermissionsModuleImpl.NAME;
-  }
-
-  @Override
-  protected Map<String, Object> getTypedExportedConstants() {
-    return RNPermissionsModuleImpl.getConstants();
-  }
-
-  @Override
-  public void openSettings(Promise promise) {
-    RNPermissionsModuleImpl.openSettings(getReactApplicationContext(), promise);
-  }
-
-  @Override
-  public void check(String permission, Promise promise) {
-    RNPermissionsModuleImpl.check(getReactApplicationContext(), permission, promise);
-  }
-
-  @Override
-  public void checkNotifications(Promise promise) {
-    RNPermissionsModuleImpl.checkNotifications(getReactApplicationContext(), promise);
-  }
-
-  @Override
-  public void checkMultiple(ReadableArray permissions, Promise promise) {
-    RNPermissionsModuleImpl.checkMultiple(getReactApplicationContext(), permissions, promise);
-  }
-
-  @Override
-  public void request(String permission, Promise promise) {
-    RNPermissionsModuleImpl.request(getReactApplicationContext(), this, mCallbacks, permission, promise);
-  }
-
-  @Override
-  public void requestNotifications(ReadableArray options, Promise promise) {
-    RNPermissionsModuleImpl.requestNotifications(getReactApplicationContext(), promise);
-  }
-
-  @Override
-  public void requestMultiple(ReadableArray permissions, Promise promise) {
-    RNPermissionsModuleImpl.requestMultiple(getReactApplicationContext(), this, mCallbacks, permissions, promise);
-  }
-
-  @Override
-  public void shouldShowRequestRationale(String permission, Promise promise) {
-    RNPermissionsModuleImpl.shouldShowRequestRationale(getReactApplicationContext(), permission, promise);
-  }
-
-  @Override
-  public void checkLocationAccuracy(Promise promise) {
-    RNPermissionsModuleImpl.checkLocationAccuracy(promise);
-  }
-
-  @Override
-  public void requestLocationAccuracy(String purposeKey, Promise promise) {
-    RNPermissionsModuleImpl.requestLocationAccuracy(promise);
-  }
-
-  @Override
-  public void openPhotoPicker(Promise promise) {
-    RNPermissionsModuleImpl.openPhotoPicker(promise);
-  }
-
-  @Override
-  public boolean onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
-    return RNPermissionsModuleImpl.onRequestPermissionsResult(getReactApplicationContext(), mCallbacks, requestCode, grantResults);
-  }
+public class RNPermissionsModule extends ReactContextBaseJavaModule implements ActivityEventListener, PermissionListener {
+
+    private final SparseArray<Callback> mCallbacks;
+    private static final int REQUEST_CODE_SCHEDULE_EXACT_ALARM = 1;
+    private Promise permissionPromise;
+
+    public RNPermissionsModule(ReactApplicationContext reactContext) {
+        super(reactContext);
+        mCallbacks = new SparseArray<Callback>();
+        reactContext.addActivityEventListener(this);
+    }
+
+    @NonNull
+    @Override
+    public String getName() {
+        return RNPermissionsModuleImpl.NAME;
+    }
+
+    @Nullable
+    @Override
+    public Map<String, Object> getConstants() {
+        return RNPermissionsModuleImpl.getConstants();
+    }
+
+    @ReactMethod
+    public void openSettings(Promise promise) {
+        RNPermissionsModuleImpl.openSettings(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void check(String permission, Promise promise) {
+        RNPermissionsModuleImpl.check(getReactApplicationContext(), permission, promise);
+    }
+
+    @ReactMethod
+    public void checkNotifications(Promise promise) {
+        RNPermissionsModuleImpl.checkNotifications(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void checkMultiple(ReadableArray permissions, Promise promise) {
+        RNPermissionsModuleImpl.checkMultiple(getReactApplicationContext(), permissions, promise);
+    }
+
+    @ReactMethod
+    public void request(String permission, Promise promise) {
+        RNPermissionsModuleImpl.request(getReactApplicationContext(), this, mCallbacks, permission, promise);
+    }
+
+    @ReactMethod
+    public void requestNotifications(ReadableArray options, Promise promise) {
+        RNPermissionsModuleImpl.requestNotifications(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void requestMultiple(ReadableArray permissions, Promise promise) {
+        RNPermissionsModuleImpl.requestMultiple(getReactApplicationContext(), this, mCallbacks, permissions, promise);
+    }
+
+    @ReactMethod
+    public void shouldShowRequestRationale(String permission, Promise promise) {
+        RNPermissionsModuleImpl.shouldShowRequestRationale(getReactApplicationContext(), permission, promise);
+    }
+
+    @ReactMethod
+    public void checkLocationAccuracy(Promise promise) {
+        RNPermissionsModuleImpl.checkLocationAccuracy(promise);
+    }
+
+    @ReactMethod
+    public void requestLocationAccuracy(String purposeKey, Promise promise) {
+        RNPermissionsModuleImpl.requestLocationAccuracy(promise);
+    }
+
+    @ReactMethod
+    public void openPhotoPicker(Promise promise) {
+        RNPermissionsModuleImpl.openPhotoPicker(promise);
+    }
+
+    @ReactMethod
+    public void checkAndRequestAlarmPermission(Promise promise) {
+        AlarmManager alarmManager = (AlarmManager) getReactApplicationContext().getSystemService(Context.ALARM_SERVICE);
+        if (alarmManager.canScheduleExactAlarms()) {
+            promise.resolve(true);
+        } else {
+            // Requesting the permission to schedule exact alarms
+            permissionPromise = promise;
+            Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);
+            Activity currentActivity = getCurrentActivity();
+            if (currentActivity != null) {
+                currentActivity.startActivityForResult(intent, REQUEST_CODE_SCHEDULE_EXACT_ALARM);
+            } else {
+                promise.reject("Activity not found");
+            }
+        }
+    }
+
+    @Override
+    public void onActivityResult(Activity activity, int requestCode, int resultCode, @Nullable Intent data) {
+        if (requestCode == REQUEST_CODE_SCHEDULE_EXACT_ALARM) {
+            if (permissionPromise != null) {
+                AlarmManager alarmManager = (AlarmManager) getReactApplicationContext().getSystemService(Context.ALARM_SERVICE);
+                permissionPromise.resolve(alarmManager.canScheduleExactAlarms());
+                permissionPromise = null;
+            }
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        // Not used
+    }
+
+    @ReactMethod
+    public void openAlarmPermissionSettings(Promise promise) {
+        RNPermissionsModuleImpl.openAlarmPermissionSettings(
+            getReactApplicationContext(),
+            promise);
+    }
+
+    @ReactMethod(isBlockingSynchronousMethod = true)
+    public boolean canScheduleExactAlarms() {
+        return RNPermissionsModuleImpl.canScheduleExactAlarms(
+            getReactApplicationContext());
+    }
+
+    @Override
+    public boolean onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        return RNPermissionsModuleImpl.onRequestPermissionsResult(getReactApplicationContext(), mCallbacks, requestCode, grantResults);
+    }
 }
diff --git a/node_modules/react-native-permissions/android/src/oldarch/com/zoontek/rnpermissions/RNPermissionsModule.java b/node_modules/react-native-permissions/android/src/oldarch/com/zoontek/rnpermissions/RNPermissionsModule.java
index 2b2f5b5..b085b17 100644
--- a/node_modules/react-native-permissions/android/src/oldarch/com/zoontek/rnpermissions/RNPermissionsModule.java
+++ b/node_modules/react-native-permissions/android/src/oldarch/com/zoontek/rnpermissions/RNPermissionsModule.java
@@ -2,6 +2,13 @@ package com.zoontek.rnpermissions;
 
 import android.util.SparseArray;
 
+import android.app.AlarmManager;
+import android.app.Activity;
+import android.provider.Settings;
+import android.content.Intent;
+import android.content.Context;
+import android.net.Uri;
+
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
@@ -11,90 +18,142 @@ import com.facebook.react.bridge.ReactApplicationContext;
 import com.facebook.react.bridge.ReactContextBaseJavaModule;
 import com.facebook.react.bridge.ReactMethod;
 import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ActivityEventListener;
 import com.facebook.react.module.annotations.ReactModule;
 import com.facebook.react.modules.core.PermissionListener;
 
 import java.util.Map;
 
 @ReactModule(name = RNPermissionsModuleImpl.NAME)
-public class RNPermissionsModule extends ReactContextBaseJavaModule implements PermissionListener {
-
-  private final SparseArray<Callback> mCallbacks;
-
-  public RNPermissionsModule(ReactApplicationContext reactContext) {
-    super(reactContext);
-    mCallbacks = new SparseArray<Callback>();
-  }
-
-  @NonNull
-  @Override
-  public String getName() {
-    return RNPermissionsModuleImpl.NAME;
-  }
-
-  @Nullable
-  @Override
-  public Map<String, Object> getConstants() {
-    return RNPermissionsModuleImpl.getConstants();
-  }
-
-  @ReactMethod
-  public void openSettings(Promise promise) {
-    RNPermissionsModuleImpl.openSettings(getReactApplicationContext(), promise);
-  }
-
-  @ReactMethod
-  public void check(String permission, Promise promise) {
-    RNPermissionsModuleImpl.check(getReactApplicationContext(), permission, promise);
-  }
-
-  @ReactMethod
-  public void checkNotifications(Promise promise) {
-    RNPermissionsModuleImpl.checkNotifications(getReactApplicationContext(), promise);
-  }
-
-  @ReactMethod
-  public void checkMultiple(ReadableArray permissions, Promise promise) {
-    RNPermissionsModuleImpl.checkMultiple(getReactApplicationContext(), permissions, promise);
-  }
-
-  @ReactMethod
-  public void request(String permission, Promise promise) {
-    RNPermissionsModuleImpl.request(getReactApplicationContext(), this, mCallbacks, permission, promise);
-  }
-
-  @ReactMethod
-  public void requestNotifications(ReadableArray options, Promise promise) {
-    RNPermissionsModuleImpl.requestNotifications(getReactApplicationContext(), promise);
-  }
-
-  @ReactMethod
-  public void requestMultiple(ReadableArray permissions, Promise promise) {
-    RNPermissionsModuleImpl.requestMultiple(getReactApplicationContext(), this, mCallbacks, permissions, promise);
-  }
-
-  @ReactMethod
-  public void shouldShowRequestRationale(String permission, Promise promise) {
-    RNPermissionsModuleImpl.shouldShowRequestRationale(getReactApplicationContext(), permission, promise);
-  }
-
-  @ReactMethod
-  public void checkLocationAccuracy(Promise promise) {
-    RNPermissionsModuleImpl.checkLocationAccuracy(promise);
-  }
-
-  @ReactMethod
-  public void requestLocationAccuracy(String purposeKey, Promise promise) {
-    RNPermissionsModuleImpl.requestLocationAccuracy(promise);
-  }
-
-  @ReactMethod
-  public void openPhotoPicker(Promise promise) {
-    RNPermissionsModuleImpl.openPhotoPicker(promise);
-  }
-
-  @Override
-  public boolean onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
-    return RNPermissionsModuleImpl.onRequestPermissionsResult(getReactApplicationContext(), mCallbacks, requestCode, grantResults);
-  }
+public class RNPermissionsModule extends ReactContextBaseJavaModule implements ActivityEventListener, PermissionListener {
+
+    private final SparseArray<Callback> mCallbacks;
+    private static final int REQUEST_CODE_SCHEDULE_EXACT_ALARM = 1;
+    private Promise permissionPromise;
+
+    public RNPermissionsModule(ReactApplicationContext reactContext) {
+        super(reactContext);
+        mCallbacks = new SparseArray<Callback>();
+        reactContext.addActivityEventListener(this);
+    }
+
+    @NonNull
+    @Override
+    public String getName() {
+        return RNPermissionsModuleImpl.NAME;
+    }
+
+    @Nullable
+    @Override
+    public Map<String, Object> getConstants() {
+        return RNPermissionsModuleImpl.getConstants();
+    }
+
+    @ReactMethod
+    public void openSettings(Promise promise) {
+        RNPermissionsModuleImpl.openSettings(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void check(String permission, Promise promise) {
+        RNPermissionsModuleImpl.check(getReactApplicationContext(), permission, promise);
+    }
+
+    @ReactMethod
+    public void checkNotifications(Promise promise) {
+        RNPermissionsModuleImpl.checkNotifications(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void checkMultiple(ReadableArray permissions, Promise promise) {
+        RNPermissionsModuleImpl.checkMultiple(getReactApplicationContext(), permissions, promise);
+    }
+
+    @ReactMethod
+    public void request(String permission, Promise promise) {
+        RNPermissionsModuleImpl.request(getReactApplicationContext(), this, mCallbacks, permission, promise);
+    }
+
+    @ReactMethod
+    public void requestNotifications(ReadableArray options, Promise promise) {
+        RNPermissionsModuleImpl.requestNotifications(getReactApplicationContext(), promise);
+    }
+
+    @ReactMethod
+    public void requestMultiple(ReadableArray permissions, Promise promise) {
+        RNPermissionsModuleImpl.requestMultiple(getReactApplicationContext(), this, mCallbacks, permissions, promise);
+    }
+
+    @ReactMethod
+    public void shouldShowRequestRationale(String permission, Promise promise) {
+        RNPermissionsModuleImpl.shouldShowRequestRationale(getReactApplicationContext(), permission, promise);
+    }
+
+    @ReactMethod
+    public void checkLocationAccuracy(Promise promise) {
+        RNPermissionsModuleImpl.checkLocationAccuracy(promise);
+    }
+
+    @ReactMethod
+    public void requestLocationAccuracy(String purposeKey, Promise promise) {
+        RNPermissionsModuleImpl.requestLocationAccuracy(promise);
+    }
+
+    @ReactMethod
+    public void openPhotoPicker(Promise promise) {
+        RNPermissionsModuleImpl.openPhotoPicker(promise);
+    }
+
+    @ReactMethod
+    public void checkAndRequestAlarmPermission(Promise promise) {
+        AlarmManager alarmManager = (AlarmManager) getReactApplicationContext().getSystemService(Context.ALARM_SERVICE);
+        if (alarmManager.canScheduleExactAlarms()) {
+            promise.resolve(true);
+        } else {
+            // Requesting the permission to schedule exact alarms
+            permissionPromise = promise;
+            Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);
+            intent.setData(Uri.parse("package:" + getReactApplicationContext().getPackageName()));
+            Activity currentActivity = getCurrentActivity();
+            if (currentActivity != null) {
+                currentActivity.startActivityForResult(intent, REQUEST_CODE_SCHEDULE_EXACT_ALARM);
+            } else {
+                promise.reject("Activity not found");
+            }
+        }
+    }
+
+    @Override
+    public void onActivityResult(Activity activity, int requestCode, int resultCode, @Nullable Intent data) {
+        if (requestCode == REQUEST_CODE_SCHEDULE_EXACT_ALARM) {
+            if (permissionPromise != null) {
+                AlarmManager alarmManager = (AlarmManager) getReactApplicationContext().getSystemService(Context.ALARM_SERVICE);
+                permissionPromise.resolve(alarmManager.canScheduleExactAlarms());
+                permissionPromise = null;
+            }
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        // Not used
+    }
+
+    @ReactMethod
+    public void openAlarmPermissionSettings(Promise promise) {
+        RNPermissionsModuleImpl.openAlarmPermissionSettings(
+            getReactApplicationContext(),
+            promise);
+    }
+
+    @ReactMethod(isBlockingSynchronousMethod = true)
+    public boolean canScheduleExactAlarms() {
+        return RNPermissionsModuleImpl.canScheduleExactAlarms(
+            getReactApplicationContext());
+    }
+
+    @Override
+    public boolean onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        return RNPermissionsModuleImpl.onRequestPermissionsResult(getReactApplicationContext(), mCallbacks, requestCode, grantResults);
+    }
 }
diff --git a/node_modules/react-native-permissions/src/NativeRNPermissions.ts b/node_modules/react-native-permissions/src/NativeRNPermissions.ts
index b084875..f12cf22 100644
--- a/node_modules/react-native-permissions/src/NativeRNPermissions.ts
+++ b/node_modules/react-native-permissions/src/NativeRNPermissions.ts
@@ -11,16 +11,19 @@ export interface Spec extends TurboModule {
     available: string[];
   };
 
+  openAlarmPermissionSettings(): Promise<void>;
   openSettings(): Promise<void>;
   check(permission: string): Promise<string>;
   checkNotifications(): Promise<NotificationsResponse>;
   request(permission: string): Promise<string>;
   requestNotifications(options: string[]): Promise<NotificationsResponse>;
+  canScheduleExactAlarms(): Boolean;
 
   // Android only part
   checkMultiple(permissions: string[]): Promise<Object>;
   requestMultiple(permissions: string[]): Promise<Object>;
   shouldShowRequestRationale(permission: string): Promise<boolean>;
+  checkAndRequestAlarmPermission(): Promise<boolean>;
 
   // iOS only part
   checkLocationAccuracy(): Promise<string>;
diff --git a/node_modules/react-native-permissions/src/contract.ts b/node_modules/react-native-permissions/src/contract.ts
index 13182cd..ede9bd8 100644
--- a/node_modules/react-native-permissions/src/contract.ts
+++ b/node_modules/react-native-permissions/src/contract.ts
@@ -9,11 +9,14 @@ import type {
 } from './types';
 
 export type Contract = {
+  canScheduleExactAlarms(): Boolean;
+  checkAndRequestAlarmPermission(): Promise<boolean>;
   check(permission: Permission): Promise<PermissionStatus>;
   checkLocationAccuracy(): Promise<LocationAccuracy>;
   checkNotifications(): Promise<NotificationsResponse>;
   openPhotoPicker(): Promise<void>;
   openSettings(): Promise<void>;
+  openAlarmPermissionSettings(): Promise<void>;
   request(
     permission: Permission,
     rationale?: Rationale | (() => Promise<boolean>),
diff --git a/node_modules/react-native-permissions/src/index.ts b/node_modules/react-native-permissions/src/index.ts
index e563669..a37e457 100644
--- a/node_modules/react-native-permissions/src/index.ts
+++ b/node_modules/react-native-permissions/src/index.ts
@@ -6,6 +6,8 @@ export {PERMISSIONS} from './permissions';
 export {RESULTS} from './results';
 export * from './types';
 
+export const canScheduleExactAlarms = methods.canScheduleExactAlarms;
+export const openAlarmPermissionSettings = methods.openAlarmPermissionSettings;
 export const check = methods.check;
 export const checkLocationAccuracy = methods.checkLocationAccuracy;
 export const checkMultiple = methods.checkMultiple;
@@ -16,17 +18,21 @@ export const request = methods.request;
 export const requestLocationAccuracy = methods.requestLocationAccuracy;
 export const requestMultiple = methods.requestMultiple;
 export const requestNotifications = methods.requestNotifications;
+export const checkAndRequestAlarmPermission = methods.checkAndRequestAlarmPermission;
 
 export default {
   PERMISSIONS,
   RESULTS,
 
+  checkAndRequestAlarmPermission,
+  canScheduleExactAlarms,
   check,
   checkLocationAccuracy,
   checkMultiple,
   checkNotifications,
   openPhotoPicker,
   openSettings,
+  openAlarmPermissionSettings,
   request,
   requestLocationAccuracy,
   requestMultiple,
diff --git a/node_modules/react-native-permissions/src/methods.android.ts b/node_modules/react-native-permissions/src/methods.android.ts
index 97d6062..3cd6ad3 100644
--- a/node_modules/react-native-permissions/src/methods.android.ts
+++ b/node_modules/react-native-permissions/src/methods.android.ts
@@ -66,6 +66,20 @@ async function checkNotifications(): Promise<NotificationsResponse> {
   return {status, settings: {}};
 }
 
+function canScheduleExactAlarms(): Boolean {
+  return NativeModule.canScheduleExactAlarms();
+}
+
+async function openAlarmPermissionSettings(): Promise<void> {
+  await NativeModule.openAlarmPermissionSettings();
+}
+
+async function checkAndRequestAlarmPermission(): Promise<boolean> {
+  const status = await NativeModule.checkAndRequestAlarmPermission();
+
+  return status;
+}
+
 async function requestNotifications(options: NotificationOption[]): Promise<NotificationsResponse> {
   if (platformVersion < TIRAMISU_VERSION_CODE) {
     return NativeModule.requestNotifications(options) as Promise<NotificationsResponse>;
@@ -90,12 +104,15 @@ function requestMultiple<P extends Permission[]>(
 }
 
 export const methods: Contract = {
+  checkAndRequestAlarmPermission,
+  canScheduleExactAlarms,
   check,
   checkLocationAccuracy,
   checkMultiple,
   checkNotifications,
   openPhotoPicker,
   openSettings,
+  openAlarmPermissionSettings,
   request,
   requestLocationAccuracy,
   requestMultiple,
diff --git a/node_modules/react-native-permissions/src/methods.ios.ts b/node_modules/react-native-permissions/src/methods.ios.ts
index 21f208a..88762d9 100644
--- a/node_modules/react-native-permissions/src/methods.ios.ts
+++ b/node_modules/react-native-permissions/src/methods.ios.ts
@@ -25,10 +25,22 @@ async function openPhotoPicker(): Promise<void> {
   await NativeModule.openPhotoPicker();
 }
 
+async function openAlarmPermissionSettings(): Promise<void> {
+  return Promise.reject();
+}
+
 async function openSettings(): Promise<void> {
   await NativeModule.openSettings();
 }
 
+function canScheduleExactAlarms(): Boolean {
+  return true;
+}
+
+async function checkAndRequestAlarmPermission(): Promise<boolean> {
+  return Promise.resolve(true);
+}
+
 async function check(permission: Permission): Promise<PermissionStatus> {
   return getAvailable().includes(permission)
     ? (NativeModule.check(permission) as Promise<PermissionStatus>)
@@ -93,12 +105,15 @@ async function requestMultiple<P extends Permission[]>(
 }
 
 export const methods: Contract = {
+  checkAndRequestAlarmPermission,
+  canScheduleExactAlarms,
   check,
   checkLocationAccuracy,
   checkMultiple,
   checkNotifications,
   openPhotoPicker,
   openSettings,
+  openAlarmPermissionSettings,
   request,
   requestLocationAccuracy,
   requestMultiple,
diff --git a/node_modules/react-native-permissions/src/methods.ts b/node_modules/react-native-permissions/src/methods.ts
index aa85422..f944e4a 100644
--- a/node_modules/react-native-permissions/src/methods.ts
+++ b/node_modules/react-native-permissions/src/methods.ts
@@ -15,6 +15,10 @@ async function checkNotifications(): Promise<NotificationsResponse> {
   return {status: RESULTS.UNAVAILABLE, settings: {}};
 }
 
+async function checkAndRequestAlarmPermission(): Promise<boolean> {
+  return Promise.resolve(true);
+}
+
 async function checkMultiple<P extends Permission[]>(
   permissions: P,
 ): Promise<Record<P[number], PermissionStatus>> {
@@ -27,12 +31,23 @@ async function checkMultiple<P extends Permission[]>(
   );
 }
 
+async function openAlarmPermissionSettings(): Promise<void> {
+  return Promise.reject();
+}
+
+function canScheduleExactAlarms(): Boolean {
+  return true;
+}
+
 export const methods: Contract = {
+  checkAndRequestAlarmPermission,
+  canScheduleExactAlarms,
   check,
   checkLocationAccuracy,
   checkMultiple,
   checkNotifications,
   openPhotoPicker,
+  openAlarmPermissionSettings,
   openSettings: Promise.reject,
   request: check,
   requestLocationAccuracy,
diff --git a/node_modules/react-native-permissions/src/methods.windows.ts b/node_modules/react-native-permissions/src/methods.windows.ts
index f7364bc..fcf7c04 100644
--- a/node_modules/react-native-permissions/src/methods.windows.ts
+++ b/node_modules/react-native-permissions/src/methods.windows.ts
@@ -19,6 +19,14 @@ async function openSettings(): Promise<void> {
   await NativeModule.OpenSettings();
 }
 
+async function openAlarmPermissionSettings(): Promise<void> {
+  return Promise.reject();
+}
+
+function canScheduleExactAlarms(): Boolean {
+  return true;
+}
+
 function check(permission: Permission): Promise<PermissionStatus> {
   return NativeModule.Check(permission);
 }
@@ -31,6 +39,10 @@ async function checkNotifications(): Promise<NotificationsResponse> {
   return {status: await NativeModule.CheckNotifications(), settings: {}};
 }
 
+async function checkAndRequestAlarmPermission(): Promise<boolean> {
+  return Promise.resolve(true);
+}
+
 async function checkMultiple<P extends Permission[]>(
   permissions: P,
 ): Promise<Record<P[number], PermissionStatus>> {
@@ -65,12 +77,15 @@ async function requestMultiple<P extends Permission[]>(
 }
 
 export const methods: Contract = {
+  checkAndRequestAlarmPermission,
+  canScheduleExactAlarms,
   check,
   checkLocationAccuracy,
   checkMultiple,
   checkNotifications,
   openPhotoPicker,
   openSettings,
+  openAlarmPermissionSettings,
   request,
   requestLocationAccuracy,
   requestMultiple,
